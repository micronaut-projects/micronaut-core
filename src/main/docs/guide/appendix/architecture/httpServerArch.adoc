The Micronaut HTTP server can be considered a Micronaut Module - that is a component of Micronaut that builds on the fundamental building blocks including <<iocArch, Dependency Injection>> and the lifecycle of the <<containerArch, ApplicationContext>>.

The HTTP server includes a set of abstract interfaces and common code contained with the `micronaut-http` and `micronaut-http-server` modules respectively (the former includes HTTP primitives shared aross the client and the server).

A default implementation of these interfaces is provided based on the https://netty.io/[Netty I/O toolkit] the architecture of which is described in the image below:

image::https://netty.io/images/components.png[]

The Netty API is in general a very low-level I/O networking API designed for integrators to use to build clients and servers that present a higher abstraction layer. The Micronaut HTTP server is one such abstraction layer.

An architecture diagram of the Micronaut HTTP server and the components used in it's implementation is described below:

image::arch/httpserver.png[]

The main entry point for running the server is the api:runtime.Micronaut[] class which implements api:context.ApplicationContextBuilder[]. Typically the developer places the following call into the `main` entry point of their application:

.Defining a `main` entry point
[source,java]
----
public static void main(String[] args) {
    Micronaut.run(Application.class, args);
}
----

NOTE: The passed arguments a transformed into a api:context.env.CommandLinePropertySource[] and available for dependency injection via <<valueAnnotation, @Value>>.

Executing `run` will start the Micronaut <<containerArch, ApplicationContext>> with the default settings and then search for a bean of type api:runtime.server.EmbeddedServer[] which is an interface that exposes information about a runnable server including host and port information. This design decouples Micronaut from the actual server implementation and whilst the default server is Netty (described above), other servers can be implemented by third-parties simply by providing an implementation of api:runtime.server.EmbeddedServer[].

A sequence diagram for how the server is started is illustrated below:

image::arch/embeddedserver.png[]

In the case of the Netty implementation the api:runtime.server.EmbeddedServer[] interface is implemented by api:http.server.netty.NettyHttpServer[].


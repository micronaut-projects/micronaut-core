The goal of <<introspection, Bean Introspections>> is to provide an alternative to reflection and the JDK's https://docs.oracle.com/en/java/javase/17/docs/api/java.desktop/java/beans/Introspector.html[Introspector API] that is coupled to the `java.desktop` module in recent versions of Java.

Many libraries in Java need to programmatically discover what methods represent properties of a class in some way and whilst the https://en.wikipedia.org/wiki/JavaBeans[JavaBeans specification] tried to establish a standard convention, the language itself has evolved to include other constructs like Records that represent properties as components.

In addition, other languages like Kotlin and Groovy have native support for class properties that need to be supported at the framework level.

The api:inject.beans.visitor.IntrospectedTypeElementVisitor[] visits declarations of the ann:core.annotation.Introspected[] annotation on types and generates at compilation time implementations of api:core.beans.BeanIntrospection[] that are associated with each annotated type:

image::arch/introspections.png[]

This generation happens via the api:inject.beans.visitor.BeanIntrospectionWriter[] class which uses the ASM bytecode generation library to generate two additional classes.

For example, given a class called `example.Person` the classes generated are:

* `example.$Person$IntrospectionRef` - an implementation of api:core.beans.BeanIntrospectionReference[] that allows the application to soft load the introspection without loading all of the metadata or the class itself (in the case where the introspected class is itself not on the classpath). Since references are loaded via link:{jdkapi}/java/util/ServiceLoader.html[ServiceLoader] an entry in a generated `META-INF/services/io.micronaut.core.beans.BeanIntrospectionReference` referring to this type is also generated at compilation time.
* `example.$Person$Introspection` - an implementation of api:core.beans.BeanIntrospection[] which contains the actual runtime introspection information.

The following example demonstrates usage of the api:core.beans.BeanIntrospection[] API:

snippet::io.micronaut.docs.ioc.beans.IntrospectionSpec[tags="usage", indent="0"]

<1> A api:core.beans.BeanIntrospection[] is looked up by type. When this occurs the introspection will be searched for amongst the api:core.beans.BeanIntrospectionReference[] instances loaded via link:{jdkapi}/java/util/ServiceLoader.html[ServiceLoader].
<2> The `instantiate` method allows creating instances
<3> Properties for bean can be loaded via one of he available methods, in this case `getRequiredProperty`
<4> The referenced api:core.beans.BeanProperty[] can be used to write mutable properties
<5> And read readable properties

NOTE: The `Person` class is only initialized when the the `getBeanType()` method is called. If the class is not present on the classpath then a `NoClassDefFoundError` will occur, to prevent this the developer can call the `isPresent()` method on the api:core.beans.BeanIntrospectionReference[] prior to trying to obtain the type.

An implementation of api:core.beans.BeanIntrospection[] performs two critical functions:

1. The introspection holds Bean metadata about the properties and constructor arguments for a particular type that is abstracted away from the actual implementation (JavaBean property, Java 17+ Record, Kotlin data classes, Groovy properties etc.) and which also provide access to api:core.annotation.AnnotationMetadata[] without needing to use reflection to load the annotations themselves.
2. The introspection enables the ability to instantiate and read/write bean properties without the use of Java reflection, based purely on the subset of build-time generated information.

Optimized reflection-free method dispatch is generated by overridding the `dispatchOne` method of api:inject.beans.AbstractInitializableBeanIntrospection[], for example:

[source,java]
----
protected final Object dispatchOne(int propertyIndex, Object bean, Object value
) {
    switch(propertyIndex) { // <1>
    case 0:
        return ((Person) bean).getName(); // <2>
    case 1:
        ((Person) bean).setName((String) value); // <3>
        return null;
    default:
        throw this.unknownDispatchAtIndexException(propertyIndex); // <4>
    }
}
----

<1> Each read or write method is assigned an index
<2> The index is used in read methods to obtain the value directly without relying on reflection
<3> The index is used for write methods to set a property without using reflection
<4> If no property exists at the index an exception is thrown, though this is implementation detail and the codepath should never arrive to this point.

NOTE: The approach to use a dispatch method with an index was used to avoid the need to generate a class per method (which would consume more memory) or introduce the overhead of lambdas.

In order to enable type instantiation the api:inject.beans.visitor.BeanIntrospectionWriter[] will also generate an implementation of the `instantiateInternal` method which contains the reflection-free code to instantiate a given type based on known valid argument types:

[source,java]
----
public Object instantiateInternal(Object[] args) {
    return new Person(
        (String)args[0], 
        (Integer)args[1]
    );
}
----
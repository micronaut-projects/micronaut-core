This section will document breaking changes between Micronaut 1.0 and Micronaut 2.0

=== @Executable No Longer Stereotype of @Around

In Micronaut 1.x the ann:context.annotation.Executable[] annotation was a meta-annotation specified on the ann:aop.Around[] and ann:aop.Introduction[] annotations. This meant that an api:inject.ExecutableMethod[] reference was generated for every usage of AOP advice which consumed additional memory unnecessarily.

In Micronaut 2.x and above this is no longer the case and if you need an api:inject.ExecutableMethod[] generated you should add the ann:context.annotation.Executable[] annotation to any custom AOP advice you specify otherwise the method will not be available via the api:inject.BeanDefinition[] interface (using for example the api:BeanDefinition.getExecutableMethods[] method).

=== Spot Bugs Instead of JSR-305 Nullable/NonNull Annotations

In Micronaut 1.x the Google distributed JSR-305 annotations library (`com.google.code.findbugs:jsr305`) was used to specify `@Nullable` and `@NonNull` on interfaces of the Micronaut API using the annotations contained within the `javax.annotation` package.

Due to the fact that JSR-305 has been cancelled and that this dependency has potential licensing issues (by using the `javax` namespace) as well as problems with the cross packages on Java 9+ with the module system Micronaut 2.x switches to the `spotbugs-annotations` module provided by the https://spotbugs.github.io/[SpotBugs project].

It is recommended users of Micronaut use this API instead (although the `javax.annotation.Nullable` and `javax.annotation.NotNull` annotations continue to be supported).

=== Source Retention Annotations No Longer Retained in Runtime Metadata

In Micronaut 1.x annotations specified as source retention were still retained in the api:core.annotation.AnnotationMetadata[] interface. As of Micronaut 2.x this is no longer the case with source retention annotations only available within the compiler APIs.

If you wish to retain a particular source level annotation when upgrading you can write an api:inject.annotation.AnnotationTransformer[] that alters the `RetentionPolicy` of the annotation.

=== Iterable Beans No Longer Have An Implicit Primary

In Micronaut 1.x injecting a single instance of an iterable bean without qualifiers would inject the first bean. An iterable bean is typically anything annotated with `@EachProperty` or `@EachBean`. Those beans typically are referenced from configuration. The first bean in this context is the first item in configuration that matches what the annotation expects.

For example if you created a bean with `@EachProperty("cars")`, then specified the following in your config:

[source,yaml]
----
cars:
    ford:
        cylinders: 8
    subaru:
        cylinders: 4
----

Requesting a single instance of that bean would result in the "ford" instance being injected. Because that behavior is surprising and inconsistent with other types of beans, that is no longer the case and a `NonUniqueBeanException` will be thrown.

NOTE: This change does not apply to an explicit primary defined in the annotation (`@EachProperty(value = "cars", primary = "ford")`), nor requesting the instance by a qualifier (`@Named("ford") CarConfig carConfig`).

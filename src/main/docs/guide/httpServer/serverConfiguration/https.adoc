Micronaut supports HTTPS out of the box. By default HTTPS is disabled and all requests are served using HTTP. To enable HTTPS support, modify your configuration. For example:

.HTTPS Configuration Example
[configuration]
----
micronaut:
  server:
    ssl:
      enabled: true
      buildSelfSigned: true
----
- Micronaut will create a self-signed certificate.

TIP: By default, Micronaut with HTTPS support starts on port `8443` but you can change the port with the property `micronaut.server.ssl.port`.

For generating self-signed certificates, the Micronaut HTTP server will use netty. Netty uses one of two approaches to generate the certificate.

If you use a pre-generated certificate (as you should, for security), these steps are not necessary.

- Netty can use the JDK-internal `sun.security.x509` package. On newer JDK versions, this package is restricted and may not work. You may need to add `--add-exports=java.base/sun.security.x509=ALL-UNNAMED` as a VM parameter.
- Alternatively, netty will use the Bouncy Castle BCPKIX API. This needs an additional dependency:

dependency:org.bouncycastle:bcpkix-jdk15on[scope="implementation"]

WARNING: This configuration will generate a warning in the browser.

image::https-warning.jpg[]

== Using a valid x509 certificate

It is also possible to configure Micronaut to use an existing valid x509 certificate, for example one created with https://letsencrypt.org/[Let's Encrypt]. You will need the `server.crt` and `server.key` files and to convert them to a PKCS #12 file.

[source,bash]
----
$ openssl pkcs12 -export \
                 -in server.crt \ # <1>
                 -inkey server.key \ # <2>
                 -out server.p12 \ # <3>
                 -name someAlias \ <4>
                 -chain -CAfile ca.crt -caname root
----
<1> The original `server.crt` file
<2> The original `server.key` file
<3> The `server.p12` file to create
<4> The alias for the certificate

During the creation of the `server.p12` file it is necessary to define a password that will be required later when using the certificate in Micronaut.

Now modify your configuration:

.HTTPS Configuration Example
[configuration]
----
micronaut:
  ssl:
    enabled: true
    key-store:
      path: classpath:server.p12
      password: mypassword
      type: PKCS12
----
- Specify the `p12` file path. It can also be referenced as `file:/path/to/the/file`
- Also provide the `password` defined during the export

With this configuration, if we start Micronaut and connect to `https://localhost:8443` we still see the warning in the browser, but if we inspect the certificate we can check that it is the one generated by Let's Encrypt.

image::https-certificate.jpg[]

Finally, we can test that the certificate is valid for the browser by adding an alias to the domain in `/etc/hosts` file:

[source,bash]
----
$ cat /etc/hosts
...
127.0.0.1   my-domain.org
...
----

Now we can connect to `https://my-domain.org:8443`:

image::https-valid-certificate.jpg[]

== Using Java Keystore (JKS)

Using this type of certificate is not recommended because the format is proprietary - PKCS12 format is preferred. Regardless, Micronaut also supports it.

Convert the `p12` certificate to a JKS one:

[source,bash]
----
$ keytool -importkeystore \
          -deststorepass newPassword -destkeypass newPassword \ # <1>
          -destkeystore server.keystore \ # <2>
          -srckeystore server.p12 -srcstoretype PKCS12 -srcstorepass mypassword \ # <3>
          -alias someAlias # <4>
----
<1> It is necessary to define the password for the keystore
<2> The file to create
<3> The PKCS12 file created previously, and the password defined during the creation
<4> The alias used before

WARNING: If either `srcstorepass` or `alias` are not the same as defined in the `p12` file, the conversion will fail.

Now modify your configuration:

.HTTPS Configuration Example
[configuration]
----
micronaut:
  ssl:
    enabled: true
    key-store:
      path: classpath:server.keystore
      password: newPassword
      type: JKS
----

Start Micronaut, and the application will run on `https://localhost:8443` using the certificate in the keystore.

== Refreshing/Reloading HTTPS Certificates

Keeping HTTPS certificates up-to-date after expiry can be a challenge. A great solution to this is https://en.wikipedia.org/wiki/Automated_Certificate_Management_Environment[Automated Certificate Management Environment] (ACME) and the https://micronaut-projects.github.io/micronaut-acme/latest/guide/index.html[Micronaut ACME Module] which provides support for automatically refreshing certificates from a certificate authority.

If the use of a certificate authority is not possible and you need to manually update certificates from disk then you should fire a api:runtime.context.scope.refresh.RefreshEvent[] using Micronaut's support for <<events, Application Events>> containing the keys where your HTTPS configuration is defined and Micronaut will reload the certificates from disk and apply the new configuration to the server.

NOTE: You can also use the <<refreshEndpoint, Refresh Management Endpoint>>, however this will only apply if the physical location of certificate on disk has changed

For example the following will reload the previously listed HTTPS configuration from disk and apply it to new incoming requests (this code could run for a <<scheduling, scheduled job>> that polled certificates for changes for example):

.Manually Refreshing HTTPS configuration
[source,java]
----
import jakarta.inject.Inject;
import io.micronaut.context.event.ApplicationEventPublisher;
import io.micronaut.runtime.context.scope.refresh.RefreshEvent;
import java.util.Collections;
...

@Inject ApplicationEventPublisher<RefreshEvent> eventPublisher;

...

eventPublisher.publishEvent(new RefreshEvent(
    Collections.singletonMap("micronaut.ssl", "*")
));
----

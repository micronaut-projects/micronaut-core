Since 4.0 Micronaut supports embedding evaluated expressions in annotation values using `#{...}` syntax which
allows to achieve even more flexibility while configuring your application.

.Evaluated Expression example
[source,groovy]
----
@Value("#{ T(Math).random() }")
double injectedValue;
----

Expressions can be defined whenever an annotation member accepts a string or an array of strings.

.Evaluated Expression in array
[source,java]
----
@Singleton
@Requires(env = {"dev", "#{ 'test' }"})
public class EvaluatedExpressionInArray {}
----

You can also embed one or more expressions in a string template in a similar manner to embedding properties with the `${...}` syntax.

.Evaluated Expression template
[source,groovy]
----
@Value("http://#{'hostname'}/#{'path'}")
String url;
----

Evaluated Expressions are validated and compiled at build time which guarantees type safety at runtime.
Once an application is running expressions are evaluated on demand as part of annotation metadata resolution. The
usage of expressions does not impact performance as evaluation process is completely reflection free.
Note that, for security reasons expressions cannot be dynamically compiled at runtime from potentially untrusted
input. All expressions are compiled and checked statically during the compilation process of the application with
errors reported as compilation failures.

== Evaluated Expression Language Reference

The Evaluated Expressions syntax supports the following functionality:

* Literal Values
* Math Operators
* Comparison Operators
* Logical Operators
* Ternary Operator
* Type References
* Method Invocation
* Property Access

=== Literal Values

The following types of literal values are supported:

* `null`
* boolean values (`true`, `false`)
* strings, which need to be surrounded with single quotation mark (`'`)
* numeric values (`int`, `long`, `float`, `double`)

Integer and Long values can also be specified in hexadecimal or octal notation. Float and Double values can also be
specified in exponential notation. All numeric values can be negative as well.

.Literal values examples
[source]
----
#{ null }
#{ true }
#{ 'string value' }
#{ 10 }
#{ 0xFFL }
#{ 10L }
#{ .123f }
#{ 1E+1d }
#{ 123D }
----

=== Math Operators

The supported mathematical operators are `+`, `-`, `*`, `/`, `%`, `^`. Math operators can only be applied to numeric
values (except `+` which can be used for string concatenation as well). Mathematical operations are performed in order
enforced by standard operator precedence. You can also change evaluation order by using brackets `()`.

`/` and `%` operators can be aliased by `div` and `mod` keywords respectively.

.Math operators examples
[source]
----
#{ 1 + 2 }             // 3
#{ 'a' + 'b' + 'c' }   // 'abc'
#{ 7 - 3 }             // 4
#{ 7 * 3 }             // 21
#{ 7 * ( 3 + 1) }      // 28

#{ 15 / 3 }            // 5
#{ 15 div 3 }          // 5

#{ 15 % 3 }            // 0
#{ 15 mod 3 }          // 0

// Unlike in Java, ^ operator means exponentiation
#{ 3 ^ 2 }             // 9
----

=== Comparison Operators

The following comparison operators are supported: `==`, `!=`, `>`, `<`, `>=`, `\<=`, `matches`
Comparison operations are performed in order enforced by standard operator precedence.
You can also change evaluation order by using brackets `()`.

Equality check is supported for both primitive types and objects. It is performed using `Object.equals()` method.

`>`, `<`, `>=`, `\<=` operations can only be applied to numeric types.

`matches` keyword can be used to determine whether a string matches provided regular expression which has to
be specified as string literal. The regular expression itself will be checked for validity at compilation time.

.Comparison operators examples
[source]
----
#{ 1 + 2 == 3 }         // true
#{ 'abc' != 'abc' }     // false
#{ 7 > 3 }              // true
#{ 7 < 3 }              // false
#{ 7 >= 7 }             // true
#{ 7 <= 8 }             // false

#{ 'AbC' matches '[A-Za-z*'  }      // Compilation failure
#{ 'AbC' matches '[A-Za-z]*'  }     // true
#{ 'AbC' matches '[a-z]*'  }        // false
----

=== Logical Operators

The following logical operators are supported: `&&` (can be aliased with `and`), `||` (can be aliased with `or`),
`!`. Logical operations are performed in order enforced by standard operator precedence.
You can also change evaluation order by using brackets `()`.

.Logical operators examples
[source]
----
#{ true && false }         // false
#{ true and true }         // true

#{ true || false }         // true
#{ false or false }        // false

#{ !false }                // true
#{ !!true }                // true
----

=== Ternary Operator

A standard ternary operator is supported to allow specifying if-then-else conditional logic in expression

[source]
----
condition ? thenBranch : elseBranch
----

where `condition` evaluation should provide boolean value, and the complexity of `then` and `else` branches is not
limited.

.Ternary operator examples
[source]
----
#{ 15 > 10 ? 'a' : 'b' }    // 'a'
#{ 15 >= 16 ? 'a' : 'b' }   // 'b'
----

=== Type References

A predefined syntax construct `T(...)` can be used to reference a class. The value inside brackets should be fully
qualified class name (including the package name). The only exception is `java.lang.*` classes which can be referenced
directly by only specifying the simple class name. Primitive types can not be referenced.

Type References are evaluated in different ways depending on the context.

==== Simple type reference

A simple type reference is resolved as a `Class<?>` object.

.Type reference example
[source]
----
#{ T(java.lang.String) }    // String.class
----

Same rule applies if type reference is specified as method argument.

==== Type check with `instanceof`

Type Reference can be used as right-hand side part of `instanceof` operator

.Type check example
[source]
----
#{ 'abc' instanceof T(String) }  // true
----

which is equivalent to the following Java code and will be evaluated as boolean value:

[source]
----
"abc" instanceof String
----

==== Static method invocation

Type Reference can be used to invoke static method of a class

.Static method invocation
[source]
----
#{ T(Math).random() }
----

=== Expression Evaluation Context

By default, the only methods you can invoke inside Evaluated Expressions are static methods using type references.

To invoke non-static methods, you need to place `@EvaluatedExpressionContext` annotation on a class owning the
method you want to invoke inside expression. In this case the annotated class is registered within evaluation context
which makes its methods and properties available for referencing in evaluated expressions. Any context reference
needs to be prefixed with `#` sign.

Consider the following example:

.User-defined evaluated expression context
[source, java]
----
import io.micronaut.context.annotation.EvaluatedExpressionContext;
import jakarta.inject.Singleton;
import java.util.Random;

@EvaluatedExpressionContext
public class CustomEvaluationContext {

    public int generateRandom(int min, int max) {
        return new Random().nextInt(max - min) + min;
    }

}
----

Method `generateRandom(int, int)` can now be used within Evaluated Expression in the following way:

.Usage of user-defined evaluated expression context
[source, java]
----
import io.micronaut.context.annotation.Value;
import jakarta.inject.Singleton;

@Singleton
public class ContextConsumer {

    @Value("#{ #generateRandom(1, 10) }")
    public int randomField;

}
----

Note that annotating a class with `@EvaluatedExpressionContext` makes it a bean. By default, it will be treated as
singleton, but you can specify an alternative scope if required. At runtime, the bean will be retrieved from
application context and respective method will be invoked.

If a matching method is not found within evaluation context at compilation time, the compilation will fail. A
compilation error will also occur if multiple suitable methods are found in the evaluation context, keep that in mind
if you annotate multiple classes with `@EvaluatedExpressionContext`.

The methods will be considered ambiguous (leading to compilation failure) when their names are the same and list of
provided arguments matches multiple methods parameters.

The class annotated with `@EvaluatedExpressionContext` needs to reside within the same module as the classes referencing
its methods or properties.

Annotating a class with `@EvaluatedExpressionContext` makes its methods and properties available for evaluated
expressions within any annotation. However, you can also specify evaluation context scoped to concrete annotation or
annotation member using `@AnnotationExpressionContext`.

.Usage of annotation level evaluated expression context
[source, java]
----
import jakarta.inject.Singleton;
import io.micronaut.context.annotation.AnnotationExpressionContext;

@Singleton
@CustomAnnotation(value = "#{ #firstValue() + #secondValue() }")
class Expr {
}

@Singleton
class AnnotationContext {
    String firstValue() {
        return "fist value";
    }
}

@Singleton
class AnnotationMemberContext {
    String secondValue() {
        return "second value";
    }
}

@AnnotationExpressionContext(AnnotationContext.class)
@interface CustomAnnotation {

    @AnnotationExpressionContext(AnnotationMemberContext.class)
    String value();
}
----

In this case the context classes need to be explicitly defined as beans to make them available for retrieval from
application context at runtime.

=== Method Invocation

You can invoke both static methods using type references, methods from evaluation context and methods on objects,
which means method chaining is supported.

.Chaining methods in expression
[source, java]
----
import io.micronaut.context.annotation.EvaluatedExpressionContext;
import io.micronaut.context.annotation.Value;
import jakarta.inject.Singleton;

@EvaluatedExpressionContext
class CustomEvaluationContext {

    public String stringValue() {
        return "stringValue";
    }

}

@Singleton
class ContextConsumer {

    @Value("#{ #stringValue().length() }")
    public int stringLength;

}
----

Varargs methods invocation is supported as well. Note that if last parameter of a method is an array, you can still
invoke it providing list of arguments separated by comma without explicitly wrapping it into array. So in this case
it will be treated in same way as if last method argument was explicitly specified as varargs parameter.

.Invoking varargs methods in expressions
[source, java]
----
import io.micronaut.context.annotation.EvaluatedExpressionContext;
import io.micronaut.context.annotation.Value;
import jakarta.inject.Singleton;

@EvaluatedExpressionContext
class CustomEvaluationContext {

    public int countIntegers(int... values) {
        return values.length;
    }

    public int countStrings(String[] values) {
        return values.length;
    }

}

@Singleton
class ContextConsumer {

    @Value("#{ #countIntegers(1, 2, 3) }")
    public int totalIntegers;

    @Value("#{ #countStrings('a', 'b', 'c') }")
    public int totalStrings;

}
----

=== Property Access

JavaBean properties can be accessed simply be referencing their names from evaluation context prefixed with `#`. Bean
properties can also be chained with dot in the same way as methods.

.Accessing bean properties in expressions
[source, java]
----
import io.micronaut.context.annotation.EvaluatedExpressionContext;
import io.micronaut.context.annotation.Value;
import jakarta.inject.Singleton;

@EvaluatedExpressionContext
class CustomEvaluationContext {

    public String getName() {
        return "Bob";
    }

    public int getAge() {
        return 25;
    }

}

@Singleton
class ContextConsumer {

    @Value("#{ 'Name is ' + #name + ', age is ' + #age }")
    public String value;

}
----

The Micronaut framework supports the following types of dependency injection:

* Constructor injection (must be one public constructor or a single constructor annotated with `@Inject`)
* Field injection
* JavaBean property injection
* Method parameter injection

NOTE: Classes or particular fields, methods can be excluded by adding an annotation ann:core.annotation.Vetoed[]

TIP: See the guide for https://guides.micronaut.io/latest/micronaut-dependency-injection-types.html[Micronaut Dependency Injection Types] to learn more.

=== Constructor Injection

Constructor injection is when dependencies are injected into the constructor for a type.

Constructor injection is the preferred and recommended injection type because Constructor injection:

* Allows immutable types
* Doesn't require an additional annotation
* Is less likely to result in a `NullPointerException`
* More clearly expresses the dependencies of a particular type in one place.

The example in the previous section used constructor injection. Note that if you have multiple constructors you can disambiguate which constructor to invoke with the `jakarta.inject.Inject` annotation or the ann:core.annotation.Creator[] annotation:

.Example of Constructor Injection
snippet::io.micronaut.docs.ioc.injection.ctor.Vehicle[indent="0"]

<1> Multiple constructors are defined so `@Inject` is used to select the correct constructor.
<2> The ann:core.annotation.Creator[] annotation can also be used to select a `static` factory method to use as a constructor.

In the above example retrieving the `Vehicle` type from the link:{api}/io/micronaut/context/BeanContext.html[BeanContext] will result in calling the `Vehicle(Engine engine)` constructor which will in turn resolve the `Engine` using the `getDefault()` method since it is annotated with `@Creator`.

NOTE: If no `@Inject` or `@Creator` is specified Micronaut will try to locate the first `public` constructor in the class otherwise a compilation error will occur.

If there are multiple possible candidates for a particular constructor argument a qualifier can be specified (such as `jakarta.inject.Named`) to disambiguate the injection. If it is not possible to disambiguate then the result will be a api:context.exceptions.NonUniqueBeanException[]. See the <<qualifiers, Qualifiers>> section for more information.

WARNING: If you use `@Inject` on a `private` constructor then the type will be instantiated via the Java reflection API which is not recommended.

=== Field Injection

You can inject non-final Java fields by annotating the field with `jakarta.inject.Inject`, for example:

.Example of Field Injection
snippet::io.micronaut.docs.ioc.injection.field.Vehicle[indent="0"]

<1> The field is annotated with `jakarta.inject.Inject`.
<2> Note that for Kotlin instead of an optional type (a type ending with `?`) you can use `lateinit var`

Trying to inject a field that is declared `final` will result in a compilation error. Field injection should be seen as inferior to constructor inject as explained in the previous sections since it can result in the code being less-structured, harder to read and harder to test.

WARNING: If the field is `private` scope or inaccessible then the field will be injected using the Java reflection API which is not recommended.

=== Method Injection

You can inject methods by annotating the method with `jakarta.inject.Inject`. For each argument of the method Micronaut will attempt to resolve the method argument as a bean. If any of the methods are not resolvable a api:context.exceptions.NoSuchBeanException[] will be thrown.

.Example of Method Injection
snippet::io.micronaut.docs.ioc.injection.method.Vehicle[indent="0"]

<1> The method is annotated with `jakarta.inject.Inject` and will therefore be injected

WARNING: If the method is `private` scope or inaccessible then the method will be injected using the Java reflection API which is not recommended.

Method injection can be useful if you need post construction initializers, however in general should be avoided in favour of constructor injection where possible.

=== Optional Injection

Occasionally it is desirable for injection to be optional (ie. not fail with a api:context.exceptions.NoSuchBeanException[] if there is no candidate bean available).

For example if you are trying to build an extensible system where a default implementation is provided but consumers of your API can provide a bean and that if available will be injected then you are likely interested in making the injection optional.

One way to make injection optional is to annotate the injected type with ann:core.annotation.Nullable[] which will result in `null` being injected by the framework if the bean is unavailable:

.Example of Injecting `null`
snippet::io.micronaut.docs.ioc.injection.nullable.Vehicle[indent="0"]

<1> Here the constructor argument is annotated with ann:core.annotation.Nullable[]
<2> Since there is no bean available `null` is injected and the code has to handle the possibility that the argument could be `null.

Using ann:core.annotation.Nullable[] has the following considerations:

* Can be used with any of the injection types (constructor, method or field injection)
* Somewhere the code has to handle what happens if `null` is injected, for constructors this is easy since the constructor can handle the `null`, but for fields and methods a `@PostConstruct` method would need to be implemented to handle `null` if `null` is not desirable.
* Finally, `@Nullable` cannot be used on primitive types like `int`, `long` etc. when using <<valueAnnotation, configuration injection>>. To handle primitives you need to specify `@Bindable(defaultValue="..")` and provide a default value.

An alternative to ann:core.annotation.Nullable[], is to make the injection optional (not to be confused with `java.util.Optional`). This can be done with the ann:context.annotation.Autowired[] annotation by setting the `required` member to `false`:

.Example of Optional Injection with `@Autowired`
snippet::io.micronaut.docs.ioc.injection.optional.Vehicle[indent="0"]

<1> `@Autowired(required=false)` is declared making the injection optional.

This approach differs to using ann:core.annotation.Nullable[] since in this case if the bean is not available the injection point will not be invoked and `null` won't be injected.

However, it important to note that ann:context.annotation.Autowired[] can only be applied for method and field injection. Optional injection cannot be applied to constructor injection, because there is no way to make a constructor argument optional.

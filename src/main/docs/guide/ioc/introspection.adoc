Since Micronaut framework 1.1, a compile-time replacement for the JDK's jdk:java.beans.Introspector[] class has been included.

The api:core.beans.BeanIntrospector[] and api:core.beans.BeanIntrospection[] interfaces allow looking up bean introspections to instantiate and read/write bean properties without using reflection or caching reflective metadata, which consume excessive memory for large beans.

=== Making a Bean Available for Introspection

Unlike the JDK's jdk:java.beans.Introspector[], every class is not automatically available for introspection. To make a class available for introspection you must at a minimum enable Micronaut's annotation processor (`micronaut-inject-java` for Java and Kotlin and `micronaut-inject-groovy` for Groovy) in your build and ensure you have a runtime time dependency on `micronaut-core`.

dependency::micronaut-inject-java[scope="annotationProcessor", version="{version}"]

NOTE: For Kotlin, add the `micronaut-inject-java` dependency in `kapt` scope, and for Groovy add `micronaut-inject-groovy` in `compileOnly` scope.

dependency::micronaut-core[scope="runtimeOnly", version="{version}"]

Once your build is configured you have a few ways to generate introspection data.

==== Use the `@Introspected` Annotation

The ann:core.annotation.Introspected[] annotation can be used on any class to make it available for introspection. Simply annotate the class with ann:core.annotation.Introspected[]:

snippet::io.micronaut.docs.ioc.beans.Person[tags="imports,class"]

Once introspection data has been produced at compile time, retrieve it via the api:core.beans.BeanIntrospection[] API:

snippet::io.micronaut.docs.ioc.beans.IntrospectionSpec[tags="usage", indent=0]

<1> You can retrieve a api:core.beans.BeanIntrospection[] with the static `getIntrospection` method
<2> Once you have a api:core.beans.BeanIntrospection[] you can instantiate a bean with the `instantiate` method.
<3> A api:core.beans.BeanProperty[] can be retrieved from the introspection
<4> Use the `set` method to set the property value
<5> Use the `get` method to retrieve the property value

===== Use `@Introspected` with `@AccessorsStyle`

It is possible to use <<configurationPropertiesAccessorsStyle, the `@AccessorsStyle` annotation>> with `@Introspected`:

[source, java]
----
import io.micronaut.core.annotation.AccessorsStyle;
import io.micronaut.core.annotation.Introspected;

@Introspected
@AccessorsStyle(readPrefixes = "", writePrefixes = "") // <1>
public class Person {

    private String name;
    private int age;

    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String name() { // <2>
        return name;
    }

    public void name(String name) { // <2>
        this.name = name;
    }

    public int age() { // <2>
        return age;
    }

    public void age(int age) { // <2>
        this.age = age;
    }
}
----
<1> Annotate the class with `@AccessorsStyle` to define empty read and write prefixes for getters and setters.
<2> Define the getters and setters without a prefix.

Now it is possible to retrieve the compile time generated introspection using the api:core.beans.BeanIntrospection[] API:

[source, java]
----
BeanIntrospection<Person> introspection = BeanIntrospection.getIntrospection(Person.class);
Person person = introspection.instantiate("John", 42);

Assertions.assertEquals("John", person.name());
Assertions.assertEquals(42, person.age());
----


==== Bean Fields

By default Java introspections treat only JavaBean getters/setters or Java 16 record components as bean properties. You can however define classes with public or package protected fields in Java using the `accessKind` member of the ann:core.annotation.Introspected[] annotation:

snippet::io.micronaut.docs.ioc.beans.User[tags="class", indent=0]

<1> Final fields are treated like read-only properties
<2> Mutable fields are treated like read-write properties

NOTE: The `accessKind` accepts an array so it is possible to allow for both types of accessors but prefer one or the other depending on the order they appear in the annotation. The first one in the list has priority.

IMPORTANT: Introspections on fields are not possible in Kotlin because it is not possible to declare fields directly.

==== Constructor Methods

For classes with multiple constructors, apply the ann:core.annotation.Creator[] annotation to the constructor to use.

snippet::io.micronaut.docs.ioc.beans.Vehicle[tags="class"]

<1> The ann:core.annotation.Creator[] annotation denotes which constructor to use

NOTE: This class has no default constructor, so calls to instantiate without arguments throw an api:core.reflect.exception.InstantiationException[].

==== Static Creator Methods

The ann:core.annotation.Creator[] annotation can be applied to static methods that create class instances.

snippet::io.micronaut.docs.ioc.beans.Business[tags="class"]

<1> The ann:core.annotation.Creator[] annotation is applied to the static method which instantiates the class

TIP: There can be multiple "creator" methods annotated. If there is one without arguments, it will be the default construction method. The first method with arguments will be used as the primary construction method.

==== Builders

If a type can only be constructed via the builder pattern then you can use the `builder` member of the ann:core.annotation.Introspected[] annotation to generate a dynamic builder. For example given this class:

snippet::io.micronaut.docs.ioc.builders.Person[tags="class"]

You can use the `builder()` method of the api:core.beans.BeanIntrospection[] API to construct the instance:

snippet::io.micronaut.docs.ioc.builders.IntrospectionBuilderSpec[tags="builder", indent=0]

TIP: The `builder()` method also works regardless if the type uses a builder and can be used as a general abstraction for object construction. Note however that there is a slight performance overhead vs direct instantiation via the `instantiate()` method, hence the `hasBuilder()` method can be checked if optimized code paths are needed.

==== Enums

It is possible to introspect enums as well. Add the annotation to the enum and it can be constructed through the standard `valueOf` method.

==== Use the `@Introspected` Annotation on a Configuration Class

If the class to introspect is already compiled and not under your control, an alternative option is to define a configuration class with the `classes` member of the ann:core.annotation.Introspected[] annotation set.

snippet::io.micronaut.docs.ioc.beans.PersonConfiguration[tags="class"]

In the above example the `PersonConfiguration` class generates introspections for the `Person` class.

NOTE: You can also use the `packages` member of the ann:core.annotation.Introspected[] which package scans at compile time and generates introspections for all classes within a package. Note however this feature is currently regarded as experimental.

==== Write an `AnnotationMapper` to Introspect Existing Annotations

If there is an existing annotation that you wish to introspect by default you can write an api:inject.annotation.AnnotationMapper[].

An example of this is https://github.com/micronaut-projects/micronaut-core/blob/master/inject/src/main/java/io/micronaut/inject/beans/visitor/EntityIntrospectedAnnotationMapper.java[EntityIntrospectedAnnotationMapper] which ensures all beans annotated with `javax.persistence.Entity` are introspectable by default.

NOTE: The `AnnotationMapper` must be on the annotation processor classpath.

=== The BeanWrapper API

A api:core.beans.BeanProperty[] provides raw access to read and write a property value for a given class and does not provide any automatic type conversion.

It is expected that the values you pass to the `set` and `get` methods match the underlying property type, otherwise an exception will occur.

To provide additional type conversion smarts the api:core.beans.BeanWrapper[] interface allows wrapping an existing bean instance and setting and getting properties from the bean, plus performing type conversion as necessary.

snippet::io.micronaut.docs.ioc.beans.IntrospectionSpec[tags="wrapper", indent=0]

<1> Use the static `getWrapper` method to obtain a api:core.beans.BeanWrapper[] for a bean instance.
<2> You can set properties, and the api:core.beans.BeanWrapper[] will perform type conversion, or throw api:core.convert.exceptions.ConversionErrorException[] if conversion is not possible.
<3> You can retrieve a property using `getRequiredProperty` and request the appropriate type. If the property doesn't exist a api:core.beans.exceptions.IntrospectionException[] is thrown, and if it cannot be converted a api:core.convert.exceptions.ConversionErrorException[] is thrown.

=== Jackson and Bean Introspection

Jackson is configured to use the api:core.beans.BeanIntrospection[] API to read and write property values and construct objects, resulting in reflection-free serialization/deserialization. This is beneficial from a performance perspective and requires less configuration to operate correctly with runtimes such as GraalVM native.

This feature is enabled by default; disable it by setting the `jackson.bean-introspection-module` configuration to `false`.

NOTE: Currently only bean properties (private field with public getter/setter) are supported and usage of public fields is not supported.

NOTE: This feature is currently experimental and may be subject to change in the future.
